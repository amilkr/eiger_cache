searchNodes=[{"doc":"Application API. It implements the 2 functions to register a function and to get a cached value.","ref":"Cache.html","title":"Cache","type":"module"},{"doc":"Get the value associated with key . Details: If the value for key is stored in the cache, the value is returned immediately. If a recomputation of the function is in progress, the last stored value is returned. If the value for key is not stored in the cache but a computation of the function associated with this key is in progress, wait up to timeout milliseconds. If the value is computed within this interval, the value is returned. If the computation does not finish in this interval, {:error, :timeout} is returned. If key is not associated with any function, return {:error, :not_registered}","ref":"Cache.html#get/2","title":"Cache.get/2","type":"function"},{"doc":"Registers a function that will be computed periodically to update the cache. Arguments: fun : a 0-arity function that computes the value and returns either {:ok, value} or {:error, reason} . key : associated with the function and is used to retrieve the stored value. ttl (&quot;time to live&quot;): how long (in milliseconds) the value is stored before it is discarded if the value is not refreshed. refresh_interval : how often (in milliseconds) the function is recomputed and the new value stored. refresh_interval must be strictly smaller than ttl . After the value is refreshed, the ttl counter is restarted.","ref":"Cache.html#register_function/4","title":"Cache.register_function/4","type":"function"},{"doc":"","ref":"Cache.html#t:get_result/0","title":"Cache.get_result/0","type":"type"},{"doc":"","ref":"Cache.html#t:register_function_result/0","title":"Cache.register_function_result/0","type":"type"},{"doc":"The Cache Application.","ref":"Cache.Application.html","title":"Cache.Application","type":"module"},{"doc":"Starts the main supervisor.","ref":"Cache.Application.html#start/2","title":"Cache.Application.start/2","type":"function"},{"doc":"Module responsible for storing and retrieving cache data. It uses an ETS as data store. The ETS is created with these options: named_table to allow to reference it by its name (instead of its tid) public to allow any process ( Cache.Worker s) to insert and read objects {:read_concurrency, true} because the app aims to be used on situations where concurrent read operations are much more frequent than write operations","ref":"Cache.Store.html","title":"Cache.Store","type":"module"},{"doc":"It fetches and returns a value by key. If the key doesn't exist in the table or the expires_at field is older than the current time, it returns {:error, :not_found} .","ref":"Cache.Store.html#get/1","title":"Cache.Store.get/1","type":"function"},{"doc":"Creates the ETS where the cached data will be stored.","ref":"Cache.Store.html#init/0","title":"Cache.Store.init/0","type":"function"},{"doc":"It stores a new object in the ETS. The object is a 3-tuple where: the 1st element is key the 2nd element is the expiration datetime ( DateTime.add(DateTime.utc_now(), ttl, :millisecond) ) the 3rd element is value","ref":"Cache.Store.html#store/3","title":"Cache.Store.store/3","type":"function"},{"doc":"Main Supervisor. It's a Dynamic Supervisor responsible for starting and monitoring Cache.Worker processes.","ref":"Cache.Supervisor.html","title":"Cache.Supervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Cache.Supervisor.html#child_spec/1","title":"Cache.Supervisor.child_spec/1","type":"function"},{"doc":"Starts a Cache.Worker process as a child.","ref":"Cache.Supervisor.html#start_child/4","title":"Cache.Supervisor.start_child/4","type":"function"},{"doc":"Starts the Supervisor process.","ref":"Cache.Supervisor.html#start_link/0","title":"Cache.Supervisor.start_link/0","type":"function"},{"doc":"","ref":"Cache.Supervisor.html#t:start_child_result/0","title":"Cache.Supervisor.start_child_result/0","type":"type"},{"doc":"Implements the process worker (as a Genserver ) spawned for each registered function. The workers are the responsible for running the registered functions every :refresh_interval and for updating the Cache.Store every time the functions returns a valid response ( {:ok, any()} ). The workers can also notify other processes about the next function result (See await_result/2 ).","ref":"Cache.Worker.html","title":"Cache.Worker","type":"module"},{"doc":"It asks the worker for the next execution result. If there's not worker identified with key , it returns {:error, :not_registered} . If the worker doesn't finish the execution before the timeout passes (in milliseconds), the function returns {:error, :timeout} . Notes: At the moment of sending the :await_result to the worker, the worker might be either waiting to run the next execution or in the middle of it. In both cases, the response will be the same. In other words, it doesn't matter if the execution is in progress. The important thing is if the worker finishes the execution before the timeout passes. If the execution doesn't finish before the timeout, this function returns {:error, :timeout} . But, the worker (after a successfull execution) will send the reply to the caller anyways. So, the reply will remain in the caller's mailbox.","ref":"Cache.Worker.html#await_result/2","title":"Cache.Worker.await_result/2","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Cache.Worker.html#child_spec/1","title":"Cache.Worker.child_spec/1","type":"function"},{"doc":"It spawns a new worker that will execute the registered :fun every :refresh_interval, and it will store the result in Cache.Store.","ref":"Cache.Worker.html#start_link/1","title":"Cache.Worker.start_link/1","type":"function"},{"doc":"","ref":"Cache.Worker.html#t:await_result_response/0","title":"Cache.Worker.await_result_response/0","type":"type"},{"doc":"This Elixir application implements an in-memory cache based on these requirements . Find the documentation in the doc/ folder. Once you have a local copy, you can open doc/index.html in your browser.","ref":"readme.html","title":"Periodic Self-Rehydrating Cache","type":"extras"},{"doc":"The application API is defined in the Cache module. $ mix deps.get Resolving Hex dependencies... Dependency resolution completed: ... $ iex -S mix iex(1)&gt; Cache.register_function(fn -&gt; {:ok, length(Process.list)} end, :proc_count, 120_000, 60_000) :ok iex(2)&gt; Cache.get(:proc_count) {:ok, 108} iex(3)&gt; Cache.get(:foo) # no registered key {:error, :not_registered} iex(4)&gt; Cache.register_function(fn -&gt; {:ok, :timer.sleep(30_000)} end, :slow_fn, 120_000, 60_000) :ok iex(5)&gt; Cache.get(:slow_fn, 1000) # timeout for slow executions {:error, :timeout}","ref":"readme.html#try-it","title":"Periodic Self-Rehydrating Cache - Try it","type":"extras"},{"doc":"$ mix credo --strict Checking 10 source files ... Please report incorrect results: https://github.com/rrrene/credo/issues Analysis took 0.1 seconds (0.04s to load, 0.1s running 64 checks on 10 files) 26 mods/funs, found no issues. $ mix coveralls ===&gt; Compiling parse_trans ... ==&gt; eiger_cache Compiling 5 files (.ex) Generated eiger_cache app ......... Finished in 1.7 seconds 9 tests, 0 failures Randomized with seed 471308 ---------------- COV FILE LINES RELEVANT MISSED 100.0% lib/cache.ex 70 3 0 100.0% lib/cache/application.ex 13 1 0 100.0% lib/cache/store.ex 58 6 0 100.0% lib/cache/supervisor.ex 48 5 0 100.0% lib/cache/worker.ex 129 17 0 [TOTAL] 100.0% ----------------","ref":"readme.html#run-credo-tests-and-coverage","title":"Periodic Self-Rehydrating Cache - Run credo, tests and coverage","type":"extras"}]